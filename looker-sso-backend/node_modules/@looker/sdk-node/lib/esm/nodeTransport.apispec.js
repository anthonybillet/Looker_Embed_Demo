function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
import { describe, it } from 'node:test';
import { expect } from 'expect';
import { StatusCode, sdkOk } from '@looker/sdk-rtl';
import { NodeCryptoHash, NodeTransport } from './nodeTransport';
describe('NodeTransport', () => {
  var hostname = 'https://looker.sdk';
  var settings = {
    base_url: hostname
  };
  var xp = new NodeTransport(settings);
  var fullPath = 'https://github.com/looker-open-source/sdk-codegen';
  var badPath = fullPath + '_bogus';
  it('raw request retrieves fully qualified url', _asyncToGenerator(function* () {
    var response = yield xp.rawRequest('GET', fullPath);
    expect(response).toBeDefined();
    expect(response.ok).toEqual(true);
    expect(response.method).toEqual('GET');
    expect(response.statusCode).toEqual(200);
    expect(response.statusMessage).toEqual('OK');
    expect(response.contentType).toContain('text/html');
    expect(response.body).toBeDefined();
    var html = yield response.body;
    expect(html).toContain('One SDK to rule them all, and in the codegen bind them');
  }));
  describe('transport errors', () => {
    it('gracefully handles transport errors', _asyncToGenerator(function* () {
      var response = yield xp.rawRequest('GET', badPath);
      var errorMessage = 'Not Found';
      expect(response).toBeDefined();
      expect(response.ok).toEqual(false);
      expect(response.method).toEqual('GET');
      expect(response.statusCode).toEqual(404);
      expect(response.body).toBeDefined();
      expect(response.statusMessage).toEqual(errorMessage);
    }));
  });
  it('retrieves fully qualified url', _asyncToGenerator(function* () {
    var response = yield xp.request('GET', fullPath);
    expect(response).toBeDefined();
    expect(response.ok).toEqual(true);
    if (response.ok) {
      var content = response.value;
      expect(content).toContain('One SDK to rule them all, and in the codegen bind them');
    }
  }));
  describe('ok check', () => {
    var raw = {
      method: 'GET',
      contentType: 'application/json',
      headers: {},
      url: 'bogus',
      ok: true,
      statusCode: StatusCode.OK,
      statusMessage: 'Mocked success',
      body: 'body',
      requestStarted: 1000,
      responseCompleted: 2000
    };
    it('ok is ok', () => {
      expect(xp.ok(raw)).toEqual(true);
    });
    it('All 2xx responses are ok', () => {
      raw.statusCode = StatusCode.IMUsed;
      expect(xp.ok(raw)).toEqual(true);
    });
    it('Non-2xx responses are not ok', () => {
      raw.statusCode = 422;
      expect(xp.ok(raw)).toEqual(false);
    });
  });
  it('does a standard get', _asyncToGenerator(function* () {
    var xp = new NodeTransport({});
    var actual = yield xp.rawRequest('GET', 'https://example.com');
    expect(actual).toBeDefined();
  }));
  it('just deserializes JSON into an object', _asyncToGenerator(function* () {
    var xp = new NodeTransport({});
    var resp = {
      headers: {},
      url: '',
      ok: true,
      contentType: 'application/json',
      statusCode: 200,
      statusMessage: 'mock',
      method: 'GET',
      body: "\n{\n  \"string1\": 1,\n  \"num1\": 1,\n  \"string2\": \"2\",\n  \"num2\": \"2\",\n  \"string3\": \"3\",\n  \"num3\": 3,\n  \"string4\": \"4\",\n  \"num4\": 4\n}\n",
      requestStarted: 1000,
      responseCompleted: 2000
    };
    var untyped = yield sdkOk(xp.parseResponse(resp));
    expect(untyped.string1).toBe(1);
    expect(untyped.num1).toBe(1);
    expect(untyped.string2).toBe('2');
    expect(untyped.num2).toBe('2');
    expect(untyped.string3).toBe('3');
    expect(untyped.num3).toBe(3);
    expect(untyped.string4).toBe('4');
    expect(untyped.num4).toBe(4);
    var typed = yield sdkOk(xp.parseResponse(resp));
    expect(typed.string1).toBe(1);
    expect(typed.num1).toBe(1);
    expect(typed.string2).toBe('2');
    expect(typed.num2).toBe('2');
    expect(typed.string3).toBe('3');
    expect(typed.num3).toBe(3);
    expect(typed.string4).toBe('4');
    expect(typed.num4).toBe(4);
  }));
  describe('NodeCryptoHash', () => {
    it('secureRandom', () => {
      var hasher = new NodeCryptoHash();
      var rand1 = hasher.secureRandom(5);
      expect(rand1.length).toEqual(10);
      var rand2 = hasher.secureRandom(32);
      expect(rand2.length).toEqual(64);
    });
    it('sha256hash', _asyncToGenerator(function* () {
      var hasher = new NodeCryptoHash();
      var message = 'The quick brown fox jumped over the lazy dog.';
      var hash = yield hasher.sha256Hash(message);
      expect(hash).toEqual('aLEoK5HeLAVMNmKcuN1EfxLwltPjxYeXjcIkhERjNIM=');
    }));
  });
});
//# sourceMappingURL=nodeTransport.apispec.js.map